package org.example;

import java.util.Arrays;

public class Main2 {
  public static void main(String[] args) {
    int[] numbers = {120, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    linearSearch(numbers, 10);   // чтобы найти 10 - мы сделали 10 сравнений
    linearSearch(numbers, 7);    // чтобы найти 7 - нам нужно 7 сравнений
    linearSearch(numbers, 120);  // чтобы найти 120 - нам понадобится только одно сравнение
    // если элементов в массиве 10
    // - то лучшее результат нахождения случайного элемента == 1
    // - худший результат столько сколько элементов
    // При оценке сложности нас по большей части интересует наихудший результат алгоритма
    // Для 10 десяти элементов худший результат был 10 операций
    // Для 1000 элементов худший результат это 1000

    // Как зависит худший результат от количества элементов
    // сложность данного алгоритма linearSearch будет O(n) - "о от эн"


    // Какая сложность у данного алгоритма
    int x = getThirdElement(numbers);
    // если элементов в массиве 10
    // - то лучшее результат нахождения случайного элемента == 1
    // - худший результат столько сколько элементов         == 1

    // если элементов 1000
    // - то лучшее результат нахождения случайного элемента == 1
    // - худший результат столько сколько элементов         == 1
    // для данного алгоритма нет зависимости между сложностью и количеством элементов
    // Мы можем как угодно увеличивать количество элементов,
    // однако сложность остается неизменной.
    // Такой вид сложности называет константная сложность O(1) произносится как "О от одного"

    // При оценке сложности нас интересует только изменения в зависимости от количества элементов
    // Асимптотическая оценка как раз отвечает на вопрос, как сильно деградирует производительность с ростом размера входа.

    // Какая сложность у бинарного поиска учитывая что массив отсортирован
    int[] numbers1 = {1};
    binarySearch(numbers1, 10);
    // для одного элемента = количество операций == 1
    int[] numbers2 = {1, 3, 4, 5, 6};
    binarySearch(numbers2, 10);
    // для 5 элементов = количество операций == 3
    int[] numbers3 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    binarySearch(numbers3, 13);
    // для 10 элементов = количество операций == 4
    int[] numbers6 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
    binarySearch(numbers6, 213);
    // для 15 элементов = количество операций == 4
    int[] numbers4 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20};
    binarySearch(numbers4, 213);
    // для 20 элементов = количество операций == 5
    int[] numbers5 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19};
    binarySearch(numbers5, 213);
    // для 19 элементов = количество операций == 5
    // Сколько операций потребуется для n количества элементов
    // Такая сложность называется логарифмической  O(log(n))

    // Квадратичная сложность O(n^2) "О от эн квадрат"
    // Сортировка выбором = selection sort
    // Для 3 элементов:  3 сравнений
    int[] numArr = {1, 3, 2};
    selectionSort(numArr);

    // Для 5 элементов: 10  сравнений
    int[] numArr3 = {5, 4, 3, 2, 1};
    // {1, 4, 3, 2, 5}
    // {1, 2, 3, 4, 5}

    selectionSort(numArr3);

    // Для 8 элементов в обратном порядке: 28  сравнений
    int[] numArr4 = {8, 7, 6, 5, 4, 3, 2, 1};
    selectionSort(numArr4);

    // Для 9 элементов в обратном порядке: 36  сравнений
    int[] numArr5 = {9, 8, 7, 6, 5, 4, 3, 2, 1};
    selectionSort(numArr5);

    // Для 10 элементов в обратном порядке: 45  сравнений
    int[] numArr6 = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
    selectionSort(numArr6);

    // Для 20 элементов в обратном порядке:  190 сравнений
    int[] numArr7 = {20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
    selectionSort(numArr7);
    // Квадратичная сложность часто возникает,
    // когда есть вложенный цикл
//    for (){
//      for (){
//        // квадратичная сложность
//      }
//    }
  }
  public static int getThirdElement(int[] arr){
    return arr[2];
  }
  public static boolean linearSearch(int[] arr, int x){
    for (int i=0; i < arr.length; i++){
      if (arr[i] == x){
        return true;
      }
    }
    return false;
  }
  public static boolean binarySearch(int[] array, int element) {
    int counter = 0;
    boolean contains = false;
    int left = 0;
    int right = array.length - 1;
    // вычисляем индекс середины
    int middle = left + (right - left) / 2;
    // мы постоянно повторяем одно и то же действие
    // пока left не перейдет за right
    // это случается, когда числа нет
    while (left <= right) {
      // сравниваем число, которое мы ищем
      // с центральным элементом a[middle]
      counter++;
      if (element < array[middle]) { // если число меньше центра - то двигаем правую границу
        right = middle - 1;
      } else if (element > array[middle]) { // если число больше центра - то двигаем левую границу
        left = middle + 1;
      } else {
        // а если вдруг попали в центр - то значит число нашли
        contains = true;
        break;
      }
      // если мы так и не нашли число, значит у нас изменились границы и
      // следовательно, у нас будет новый центр
      middle = left + (right - left) / 2;
    }
    System.out.println("В binarySearch было сделано " + counter + " сравнений");
    return contains;
  }
  public static void selectionSort(int[] array) {
    int counter2 = 0;
    int counter = 0;
    int currentMin;
    int indexOfCurrentMin;
    int temp;

    for (int i = 0; i < array.length; i++) {
      currentMin = array[i];
      indexOfCurrentMin = i;
      counter2 ++;

      for (int j = i + 1; j < array.length; j++) { // поиск минимального
        counter++;
        if (array[j] < currentMin) { // если a[j] меньше, чем текущий минимальный
          currentMin = array[j]; // запоминаем его как минимальный
          indexOfCurrentMin = j; // запомнили его индекс
        }
      }

      // a[0] <-> a[indexOfCurrentMin]
      temp = array[i];
      array[i] = array[indexOfCurrentMin];
      array[indexOfCurrentMin] = temp;
    }
    System.out.println("В selectionSort было сделано внешних циклов " + counter2
        + " внутренних циклов " +counter +  " сравнений");
  }




}
