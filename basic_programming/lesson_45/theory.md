# Юнит-тестирование

**Модульное тестирование**, или **юнит-тестирование** (*англ.* **unit testing**) — процесс в программировании, позволяющий проверить на корректность отдельные модули исходного кода программы.

Идея состоит в том, чтобы писать тесты для каждой нетривиальной функции или метода. Это позволяет достаточно быстро проверить, не привело ли очередное изменение кода к регрессии, то есть к появлению ошибок в уже оттестированных местах программы, а также облегчает обнаружение и устранение таких ошибок.

## Не нужно писать тесты, если

- Вы делаете простой сайт-визитку из 5 статических html-страниц и с одной формой отправки письма. На этом заказчик, скорее всего, успокоится, ничего большего ему не нужно. Здесь нет никакой особенной логики, быстрее просто все проверить «руками»
- Вы занимаетесь рекламным сайтом/простыми флеш-играми или баннерами – сложная верстка/анимация или большой объем статики. Никакой логики нет, только представление
- Вы делаете проект для выставки. Срок – от двух недель до месяца, ваша система – комбинация железа и софта, в начале проекта не до конца известно, что именно должно получиться в конце. Софт будет работать 1-2 дня на выставке
- Вы всегда пишете код без ошибок, обладаете идеальной памятью и даром предвидения. Ваш код настолько крут, что изменяет себя сам, вслед за требованиями клиента. Иногда код объясняет клиенту, что его требования не нужно реализовывать

**Тесты очень нужно писать в тестовых заданиях.**

В первых трех случаях по объективным причинам (сжатые сроки, бюджеты, размытые цели или очень простые требования) вы не получите выигрыша от написания тестов.

**Любой долгосрочный проект без надлежащего покрытия тестами обречен рано или поздно быть переписанным с нуля.**

Ваши тесты должны:
- Быть достоверными
- Не зависеть от окружения, на котором они выполняются
- Легко поддерживаться
- Легко читаться и быть простыми для понимания (даже новый разработчик должен понять, **что именно** тестируется)
- Соблюдать единую конвенцию именования
- Запускаться регулярно в автоматическом режиме

## Выберите способ именования проектов с тестами
Одна из лучших практик: добавьте к каждому проекту его собственный тестовый проект.

У вас есть части системы `<PROJECT_NAME>.Core`, `<PROJECT_NAME>.Bl` и `<PROJECT_NAME>.Web`? Добавьте еще `<PROJECT_NAME>.Core.Tests`, `<PROJECT_NAME>.Bl.Tests` и `<PROJECT_NAME>.Web.Tests`.

## Используйте такой же способ именования для тестовых классов
У вас есть класс `ProblemResolver`? Добавьте в тестовый проект `ProblemResolverTests`. Каждый тестирующий класс должен тестировать только одну сущность.

## Выберите «говорящий» способ именования методов тестирующих классов
`TestLogin` – не самое лучшее название метода. Что именно тестируется? Каковы входные параметры? Могут ли возникать ошибки и исключительные ситуации?

Один из возможных способов именования методов такой: `[Тестируемый метод]_[Сценарий]_[Ожидаемое поведение]`.

Предположим, что у нас есть класс `Calculator`, а у него есть метод `sum`, который должен складывать два числа.
В этом случае наш тестирующий класс будет выглядеть так:
```java
import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;

public сlass CalculatorTests {

	@Test
  public void sum_2Plus5_7Returned() {
    // …
  }
}
```
Такая запись понятна без объяснений. Это спецификация к вашему коду.

## Придерживайтесь единого стиля написания тела теста
Отлично зарекомендовал себя подход **AAA** (arrange, act, assert - упорядочить, выполнить действие, сравнить результат).

Вернемся к примеру с калькулятором:
```java
import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;

public class CalculatorTests {

  @Test
	public void sum_2Plus5_7Returned() {
		// arrange
		Calculator calc = new Calculator();
	
		// act
		int res = calc.sum(2, 5);

		// assert
		assertEquals(7, res);
	}
}
```
Такая форма записи гораздо легче читается, чем
```java
import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;

public class CalculatorTests {

  @Test
	public void sum_2Plus5_7Returned() {
		assertEquals(7, new Calculator().sum(2, 5));
	}
}
```

## Тестируйте одну вещь за один раз
Каждый тест должен проверять только одну вещь. Если процесс слишком сложен (например, покупка в интернет магазине), разделите его на несколько частей и протестируйте их отдельно.

Если вы не будете придерживаться этого правила, ваши тесты станут нечитаемыми, и вскоре вам окажется очень сложно их поддерживать.

# Фреймворк JUnit

**JUnit** - один из самых популярных фреймворков, используемых для тестирования кода в **Java**.

[Официальный сайт](https://junit.org/junit5/)

[Руководство пользователя](https://junit.org/junit5/docs/current/user-guide/)

[Репозиторий](https://github.com/junit-team/junit5/) на **GitHub**

[Текстовая инструкция по настройке IntelliJ Idea (на английском)](https://www.jetbrains.com/help/idea/junit.html)

[Видеоинструкция по настройке IntelliJ Idea (на английском)](https://www.youtube.com/watch?v=we3zJE3hlWE)

## Волшебные импорты

Эти два импорта заставят IntelliJ Idea предложить вам установить JUnit:
```java
import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;
```

## Зависимости вручную 
```xml
    <dependencies>
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-api</artifactId>
            <version>5.8.1</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-params</artifactId>
            <version>5.8.1</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
   ```

## Maven

### POM (Project Object Model) 
является базовым модулем Maven. Это специальный XML-файл, который всегда хранится в базовой директории проекта и называется pom.xml.

Файл POM содержит информацию о проекте и различных деталях конфигурации, которые используются Maven для создания проекта.

Этот файл также содержит задачи и плагины. Во время выполнения задач, Maven ищет файл pom.xml в базовой директории проекта. Он читает его и получает необходимую информацию, после чего выполняет задачи.

Среди конфигураций Maven мы можем выделить следующие:

- зависимости проекта
- плагины
- задачи
- профиль создания
- версия проекта
- разработчики
- список рассылки
Перед тем, как создавать pom.xml  нам необходимо прежде всего определить группу проекта (groupId), его имя (artifactId) и его версию. Все это поможет нам унифицировать проект для простой его идентификации в репозитории.