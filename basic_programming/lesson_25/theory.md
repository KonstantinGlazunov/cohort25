
# `ArrayList`
Ссылка на презентацию: [ссылка](https://github.com/ait-tr/cohort25/blob/main/basic_programming/lesson_25/arrayList.pdf)

Программистам очень не нравилось одно свойство массива – его размер нельзя изменять. Что делать, если нужно сохранить в массиве ещё три элемента, а свободное место только одно?

Единственным решением проблемы нехватки места в массиве было создание массива очень большого размера, чтобы все элементы туда точно поместились. Но это часто приводило к нерациональному расходу памяти. Если чаще всего в массиве хранилось три элемента, но был хотя бы мизерный шанс, что там их будет 100, приходилось создавать массив на 100 элементов.

Поэтому они написали класс `ArrayList` (списочный массив), который выполнял ту же работу, что и массив, но мог изменять свой размер.

Внутри каждого объекта типа ArrayList хранится обычный массив элементов. Когда ты считываешь элементы из ArrayList, он считывает их из своего внутреннего массива. Когда записываешь – записывает их во внутренний массив. Вот сравни:

| Действие | Array | ArrayList   |
| --- | --- | --- |
| Создание контейнера элементов | `String[] list = new String[10];` | `ArrayList<String> list = new ArrayList<String>();` |
| Получение количества элементов | `int n = list.length;` | `int n = list.size();` |
| Взятие элемента из массива/коллекции | `String s = list[3];` | `String s = list.get(3);` |
| Запись элемента в массив | `list[3] = s;` | `list.set(3, s);` |

# Преимущества `ArrayList`

- Во-первых, `ArrayList` поддерживает несколько дополнительных действий, которые очень часто приходится делать программистам во время работы, и которых нет у массива. Например – вставка и удаление элементов из середины массива, и чтобы не оставалось дырок.
- Во-вторых, изменение размера: когда нужно записать во внутренний массив ещё один элемент, а свободного места там нет, то внутри `ArrayList` делается вот что:
    - создаётся ещё один массив, в полтора раза больше размера внутреннего массива, плюс один элемент.
    - все элементы из старого массива копируются в новый массив.
    - новый массив сохраняется во внутренней переменной объекта `ArrayList`, старый массив объявляется мусором (мы просто перестаём хранить на него ссылку).

| Действие | Array | ArrayList |
| --- | --- | --- |
| Добавление элемента в конец массива | Невозможно выполнить данное действие | `list.add(s);` |
| Вставка элемента в середину массива | Невозможно выполнить данное действие | `list.add(15, s);` |
| Вставка элемента в начало массива | Невозможно выполнить данное действие | `list.add(0, s);` |
| Удаление элемента из массива | Можно стереть элемент с помощью `list[3] = null.` Но тогда останется «дыра» в массиве. | `list.remove(3);` |

# Дженерики (Generics)

“Дженерики” – это типы с параметром. В Java классы-контейнеры позволяют указывать тип их внутренних объектов.

Когда мы объявляем generic-переменную, то мы указываем не один тип, а два: тип переменной и тип данных, которые она у себя хранит.

Хороший пример этого – `ArrayList`. Когда мы создаём новый объект/переменную типа `ArrayList`, нам удобно указать, значения какого типа будут храниться внутри этого списка.

В качестве типа-параметра можно поставить любой класс (даже собственный), **кроме примитивных типов**.

Для примитивных типов разработчики языка Java написали их непримитивные аналоги. Вот как это будет выглядеть:

| Примитивный тип | Класс | Список |
| --- | --- | --- |
| `int` | `Integer` | `ArrayList<Integer>` |
| `double` | `Double` | `ArrayList<Double>` |
| `boolean` | `Boolean` | `ArrayList<Boolean>` |
| `char` | `Character` | `ArrayList<Character>` |
| `byte` | `Byte` | `ArrayList<Byte>` |

Примитивные типы и их классы-аналоги (классы-обёртки) можно спокойно присваивать друг другу:
```java
int a = 5;
Integer b = a;
int c = b;
```